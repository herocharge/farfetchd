<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>FarFetch&#39;d</title>
    <link>http://localhost:1313/</link>
    <description>Recent content on FarFetch&#39;d</description>
    <generator>Hugo -- 0.147.5</generator>
    <language>en-us</language>
    <lastBuildDate>Sat, 24 May 2025 00:00:00 +0000</lastBuildDate>
    <atom:link href="http://localhost:1313/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Evolution: an introduction</title>
      <link>http://localhost:1313/posts/evolution/</link>
      <pubDate>Sat, 24 May 2025 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/posts/evolution/</guid>
      <description>&lt;p&gt;Note: This is a philosophical post. It is neither intended to be accurate nor make sense.&lt;/p&gt;
&lt;p&gt;Hey class! Today we are going to learn about a process called &lt;em&gt;Evolution&lt;/em&gt;. This process is the current best explanation of how we ended up the way we are. Before we start, I would like to announce that the midterms are going to be constrained tokens style, just to make it easier.&lt;/p&gt;
&lt;p&gt;Anyway, we all know that as a consequence of the first law of &lt;em&gt;information dynamics&lt;/em&gt;, states in the universe evolve in a constrained manner, i.e, certain future states are more likely than others. If we assume that at the start of the universe there is a uniform distribution of all possible systems (Here a system could refer to a collection of atoms, etc). Some systems are more likely to make it to the next time step than others. The others might change to a state which survived or might cease to exist. Earlier scientists called this &amp;ldquo;survival of the fittest&amp;rdquo;. The constraints of the universe were compared to a &lt;em&gt;fitness test&lt;/em&gt; that a system needed to pass to survive to the next time step.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Percentage is weird</title>
      <link>http://localhost:1313/posts/percentage/</link>
      <pubDate>Sat, 05 Apr 2025 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/posts/percentage/</guid>
      <description>&lt;p&gt;The idea of percentage 1%, 2%, 3%, &amp;hellip;., etc. is something pretty much everyone of learns in school. It&amp;rsquo;s a nice of way of capturing fractions. Instead of saying 1 hudredth, we can say 1 percent (rolls off the tongue easier too). We sometimes say 50% instead of half, to seem fancy perhaps. The number infront of the percent sign could be anything, so we can have 0.01% or 2000% and it still works (although a bit more confusing).&lt;/p&gt;</description>
    </item>
    <item>
      <title>PyObserve: A Proposal</title>
      <link>http://localhost:1313/posts/pyobserve/</link>
      <pubDate>Sat, 05 Apr 2025 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/posts/pyobserve/</guid>
      <description>&lt;p&gt;I don&amp;rsquo;t know if this already exists but it just popped in my head like &amp;ldquo;Yeah, that would be cool if it existed.&amp;rdquo;&lt;/p&gt;
&lt;p&gt;Here&amp;rsquo;s the problem. Whenever I write code in python notebooks, I forget to save the variables that I might wanna analyze later. I forget to use something like like &lt;code&gt;tqdm&lt;/code&gt; to print a progress bar, so that I know how long the cell will run.&lt;/p&gt;
&lt;p&gt;Sometimes I don&amp;rsquo;t forget and save most of things which I think I need, but later realize that I might want to see what the other variables were storing?&lt;/p&gt;</description>
    </item>
    <item>
      <title>where tf is the print statement</title>
      <link>http://localhost:1313/posts/wheres_the_print/</link>
      <pubDate>Wed, 26 Mar 2025 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/posts/wheres_the_print/</guid>
      <description>&lt;p&gt;I was revisting one of my projects from a long time ago. It was written in python and I wanted to quickly run and see the output. But once I run it I am immediately bombarded with a tonne of &amp;ldquo;debug print&amp;rdquo; statements. Well&amp;hellip;. I don&amp;rsquo;t use debuggers for python.&lt;/p&gt;
&lt;p&gt;I commented out all the debug prints. Luckily I always include a &amp;ldquo;[HERO]&amp;rdquo; tag in my debug prints (I should&amp;rsquo;ve used loggers instead). Anyway, I ran the code again, and&amp;hellip;. there is still a debug print remaining. I can see it in the output. I went through the code again and again but couldnt find it.&lt;/p&gt;</description>
    </item>
    <item>
      <title>About thinking time in LLMs</title>
      <link>http://localhost:1313/posts/thinking_time_llms/</link>
      <pubDate>Mon, 16 Dec 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/posts/thinking_time_llms/</guid>
      <description>&lt;h3 id=&#34;introduction&#34;&gt;Introduction&lt;/h3&gt;
&lt;p&gt;Note: citation needed&lt;/p&gt;
&lt;p&gt;Let&amp;rsquo;s take a detour and think about how WE(for the humans reading this blog) think.
Our thinking time depends on the question posed. Every question has a certain complexity.&lt;br&gt;
This complexity isn&amp;rsquo;t necessarily proportional to the length of the question (number of characters).&lt;/p&gt;
&lt;p&gt;For example, something like &lt;code&gt;&amp;quot;If I have 2 sons and 2 daughters, how many kids do I have?&amp;quot;&lt;/code&gt;(58 characters) is easy,
because it is essentially asking 2+2. Well&amp;hellip; you do need to have knowledge of english and the understanding that both daughters and sons count as kids equally(although some seem to disagree).&lt;br&gt;
Whereas the question &lt;code&gt;&amp;quot;What is the 13337th digit of PI?&amp;quot;&lt;/code&gt;(32 characters) is much harder because one needs to start computing the digits of PI upto the 13337th digit, which I don&amp;rsquo;t think a human has enough patience to do even if they have all the requisite knowledge.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Binning in FHE with CKKS encoding</title>
      <link>http://localhost:1313/posts/ckks_binning/</link>
      <pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/posts/ckks_binning/</guid>
      <description>&lt;h3 id=&#34;introduction&#34;&gt;Introduction&lt;/h3&gt;
&lt;p&gt;Fully homomorphic encryption (FHE) let&amp;rsquo;s you perform computation on encrypted data. There are many different FHE schemes. Along with the encryption schemes, there is usually an encoding scheme which can take numbers in one space and turn them into numbers which can be encrypted using the encryption scheme. One such encoding scheme which can encode complex numbers is CKKS.&lt;/p&gt;
&lt;p&gt;I will not get into the details of how FHE internals work. For the purposes of this blog, I will be using a nice abstraction provided by the Microsoft SEAL library. In fact, I will be using a python wrapper of the library called tenseal.&lt;/p&gt;</description>
    </item>
    <item>
      <title></title>
      <link>http://localhost:1313/posts/llm_addons/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/posts/llm_addons/</guid>
      <description></description>
    </item>
  </channel>
</rss>
